# Can read point cloud stream from ROS2
# Colors don't work. 
# Decided this was our guy after being able to accurately position
# The point cloud resulting from camera filtering 
# on top of the cloud generated by the simulator. 
# Note, still needs to be added to setup.py

import numpy as np
import open3d as o3d
import cv2
from cv_bridge import CvBridge
import rclpy
from rclpy.node import Node
import std_msgs.msg
from sensor_msgs.msg import PointField
from sensor_msgs.msg import Image, PointCloud2
from sensor_msgs_py import point_cloud2 as pc2
import ros2_numpy
import copy

### Preprocess Point Cloud
def preprocess_point_cloud(pcd, voxel_size):
        print(":: Downsample with a voxel size %.3f." % voxel_size)
        pcd_down = pcd.voxel_down_sample(voxel_size)
        radius_normal = voxel_size * 2
        print(":: Estimate normal with search radius %.3f." % radius_normal)
        pcd_down.estimate_normals(
            o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30)
        )
        radius_feature = voxel_size * 5
        print(":: Compute FPFH feature with search radius %.3f" % radius_feature)
        pcd_fpfh = o3d.pipelines.registration.compute_fpfh_feature(
            pcd_down,
            o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100)
        )
        return pcd_down, pcd_fpfh


def exec_global_reg(source_down, target_down, source_fpfh, target_fpfh, voxel_size):
     dis_threshold = voxel_size * 1.5
     print(":: RANSAC registration on downsampled point clouds.")
     print("Since the downsampling voxel size is %.3f" % voxel_size)
     print(" we use a liberal distance threshold %.3f" % dis_threshold)
     result = o3d.pipelines.registration.registration_ransac_based_on_feature_matching(
          source_down, target_down, source_fpfh, target_fpfh, True,
          dis_threshold,
          o3d.pipelines.registration.TransformationEstimationPointToPoint(False),
          3, [
               o3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength(
                    0.9
               ),
               o3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance(
                    dis_threshold
               )
          ],
          o3d.pipelines.registration.RANSACConvergenceCriteria(100000, 0.999)
     )
     return result

def draw_registration_result(source, target, transformation):
     source_temp = copy.deepcopy(source)
     target_temp = copy.deepcopy(target)
     source_temp.paint_uniform_color([1,0.706,0])
     target_temp.paint_uniform_color([0,0.651,0.929])
     source_temp.transform(transformation)
     o3d.visualization.draw_geometries([source_temp, target_temp],
                                       zoom=0.4559,
                                       front=[0.6452, -0.3036, -0.7011],
                                       lookat=[1.9892, 2.0208, 1.8945],
                                       up=[-0.2779, -0.9482, 0.1556])

# ----------------------- END OF RANSAC --------------------------#
class RGBDPointCloudReader(Node):
    def __init__(self):
        super().__init__('rgbd_point_cloud_reader')
        color_node = '/combined_mask/masked_color'
        depth_node = '/combined_mask/masked_depth'
        point_node = '/points2'
        fil_pcloud_node = '/filtered_point_cloud'
        
        # Subscriptions
        self.pcd_sub = self.create_subscription(
             PointCloud2,
             point_node,
             self.point_cloud_callback,
             10
          )
        self.color_sub = self.create_subscription(
             Image, color_node,
             self.color_callback,
             10
          )
        self.depth_sub = self.create_subscription(
             Image,
             depth_node,
             self.depth_callback,
             10
          )
        # Publisher
        self.pcd_publisher = self.create_publisher(
             PointCloud2,
             fil_pcloud_node,
             10
          )
        self.bridge = CvBridge()
        self.latest_color_image = None
        self.latest_depth_image = None
        self.generated_pcd = None

        # Camera Intrinsics
        hfov_radians = 1.57  # Horizontal field of view in radians
        image_width = 1260  # Image width in pixels
        image_height = 720  # Image height in pixels
        focal_length_px = image_width / (2 * np.tan(hfov_radians / 2))
        self.intrinsic = o3d.camera.PinholeCameraIntrinsic(
          width = image_width, 
          height = image_height, 
          fx = focal_length_px,  
          fy = focal_length_px, 
          cx = image_width / 2, 
          cy = image_height / 2
        )
    
    def color_callback(self, msg):
         self.latest_color_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")

    def depth_callback(self, msg):
         self.latest_depth_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding="passthrough")
         self.generate_point_cloud()

    def generate_point_cloud(self):
     if self.latest_color_image is None or self.latest_depth_image is None:
        return 
     # Convert image to Open3D format
     depth_o3d = o3d.geometry.Image(self.latest_depth_image.astype(np.uint16))
     # Convert color image to Open3D format
     color_temp = cv2.cvtColor(self.latest_color_image, cv2.COLOR_BGR2RGB)
     color_o3d = o3d.geometry.Image(color_temp)
     # Create RGB-D image from color and depth
     rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
          color_o3d,
          depth_o3d,
          depth_scale = 1000.0,
          depth_trunc = 0.75,
          convert_rgb_to_intensity=False
     )
     # Generate point cloud 
     pcd = o3d.geometry.PointCloud.create_from_rgbd_image(
          rgbd_image,
          self.intrinsic
     )
     self.generated_pcd = pcd

    def point_cloud_callback(self, msg):
        parent_frame_id = msg.header.frame_id
        print(f"The parent frame of the point cloud is: {parent_frame_id}")
        # Convert the PointCloud2 message to a numpy array
        cloud_arr = ros2_numpy.point_cloud2.point_cloud2_to_array(msg)
        points = cloud_arr['xyz']

        # Create an Open3D point cloud object
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(points)

        min_dis_threshold = 0.1# Overhead perspective#0.1 # Min dist threshold in meters
        max_dis_threshold = 2# Overhead perspective#0.7 # Max Distance threshold in meters
        points = np.asarray(pcd.points)
        distances = np.linalg.norm(points, axis=1)
        mask = (distances > min_dis_threshold) & (distances < max_dis_threshold)
        filtered_points = points[mask]
        filtered_pcd = o3d.geometry.PointCloud()
        filtered_pcd.points = o3d.utility.Vector3dVector(filtered_points)

        if self.generated_pcd is not None:
            pcd2 = self.generated_pcd

            points_pcd2 = np.asarray(pcd2.points)
            ros_dtype = PointField.FLOAT32
            dtype = np.float32
            itemsize = np.dtype(dtype).itemsize
            point_fields = ['x', 'y', 'z']

            fields = [PointField(name=n, offset=i*itemsize, datatype=ros_dtype, count=1) for i, n in enumerate(point_fields)]

            header = std_msgs.msg.Header(frame_id=parent_frame_id)

            data = points_pcd2.astype(dtype).tobytes()

            publish_ready_pc = PointCloud2(header=header, height=1, width=points_pcd2.shape[0], is_dense=False, is_bigendian=False, fields=fields, point_step=(itemsize*3), row_step=(itemsize*3*points_pcd2.shape[0]), data=data)

            self.pcd_publisher.publish(publish_ready_pc)            
        else:
             print("Generated point cloud (pcd2) is not available.")


def main(args=None):
    rclpy.init(args=args)
    node = RGBDPointCloudReader()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
    